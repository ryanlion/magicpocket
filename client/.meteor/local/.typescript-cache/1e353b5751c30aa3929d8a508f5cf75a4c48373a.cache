{"code":"\"use strict\";\r\nconst parties_collection_1 = require(\"../collections/parties.collection\");\r\nconst email_1 = require(\"meteor/email\");\r\nconst check_1 = require(\"meteor/check\");\r\nconst meteor_1 = require(\"meteor/meteor\");\r\nfunction getContactEmail(user) {\r\n    if (user.emails && user.emails.length)\r\n        return user.emails[0].address;\r\n    return null;\r\n}\r\nmeteor_1.Meteor.methods({\r\n    invite: function (partyId, userId) {\r\n        check_1.check(partyId, String);\r\n        check_1.check(userId, String);\r\n        let party = parties_collection_1.Parties.collection.findOne(partyId);\r\n        if (!party)\r\n            throw new meteor_1.Meteor.Error('404', 'No such party!');\r\n        if (party.public)\r\n            throw new meteor_1.Meteor.Error('400', 'That party is public. No need to invite people.');\r\n        if (party.owner !== this.userId)\r\n            throw new meteor_1.Meteor.Error('403', 'No permissions!');\r\n        if (userId !== party.owner && (party.invited || []).indexOf(userId) == -1) {\r\n            parties_collection_1.Parties.collection.update(partyId, { $addToSet: { invited: userId } });\r\n            let from = getContactEmail(meteor_1.Meteor.users.findOne(this.userId));\r\n            let to = getContactEmail(meteor_1.Meteor.users.findOne(userId));\r\n            if (meteor_1.Meteor.isServer && to) {\r\n                email_1.Email.send({\r\n                    from: 'noreply@socially.com',\r\n                    to: to,\r\n                    replyTo: from || undefined,\r\n                    subject: 'PARTY: ' + party.name,\r\n                    text: `Hi, I just invited you to ${party.name} on Socially.\n                        \\n\\nCome check it out: ${meteor_1.Meteor.absoluteUrl()}\\n`\r\n                });\r\n            }\r\n        }\r\n    },\r\n    reply: function (partyId, rsvp) {\r\n        check_1.check(partyId, String);\r\n        check_1.check(rsvp, String);\r\n        if (!this.userId)\r\n            throw new meteor_1.Meteor.Error('403', 'You must be logged-in to reply');\r\n        if (['yes', 'no', 'maybe'].indexOf(rsvp) === -1)\r\n            throw new meteor_1.Meteor.Error('400', 'Invalid RSVP');\r\n        let party = parties_collection_1.Parties.findOne({ _id: partyId });\r\n        if (!party)\r\n            throw new meteor_1.Meteor.Error('404', 'No such party');\r\n        if (party.owner === this.userId)\r\n            throw new meteor_1.Meteor.Error('500', 'You are the owner!');\r\n        if (!party.public && (!party.invited || party.invited.indexOf(this.userId) == -1))\r\n            throw new meteor_1.Meteor.Error('403', 'No such party'); // its private, but let's not tell this to the user\r\n        let rsvpIndex = party.rsvps ? party.rsvps.findIndex((rsvp) => rsvp.userId === this.userId) : -1;\r\n        if (rsvpIndex !== -1) {\r\n            // update existing rsvp entry\r\n            if (meteor_1.Meteor.isServer) {\r\n                // update the appropriate rsvp entry with $\r\n                parties_collection_1.Parties.update({ _id: partyId, 'rsvps.userId': this.userId }, { $set: { 'rsvps.$.response': rsvp } });\r\n            }\r\n            else {\r\n                // minimongo doesn't yet support $ in modifier. as a temporary\r\n                // workaround, make a modifier that uses an index. this is\r\n                // safe on the client since there's only one thread.\r\n                let modifier = { $set: {} };\r\n                modifier.$set['rsvps.' + rsvpIndex + '.response'] = rsvp;\r\n                parties_collection_1.Parties.update(partyId, modifier);\r\n            }\r\n        }\r\n        else {\r\n            // add new rsvp entry\r\n            parties_collection_1.Parties.update(partyId, { $push: { rsvps: { userId: this.userId, response: rsvp } } });\r\n        }\r\n    }\r\n});\r\n//# sourceMappingURL=parties.methods.js.map","sourceMap":{"version":3,"file":"parties.methods.js","sourceRoot":"","sources":["both/methods/parties.methods.ts"],"names":[],"mappings":"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","sourcesContent":["import {Parties} from '../collections/parties.collection';\nimport {Email} from 'meteor/email';\nimport {check} from 'meteor/check';\nimport {Meteor} from 'meteor/meteor';\n\nfunction getContactEmail(user:Meteor.User):string {\n  if (user.emails && user.emails.length)\n    return user.emails[0].address;\n\n  return null;\n}\n\nMeteor.methods({\n  invite: function (partyId:string, userId:string) {\n    check(partyId, String);\n    check(userId, String);\n\n    let party = Parties.collection.findOne(partyId);\n\n    if (!party)\n      throw new Meteor.Error('404', 'No such party!');\n\n    if (party.public)\n      throw new Meteor.Error('400', 'That party is public. No need to invite people.');\n\n    if (party.owner !== this.userId)\n      throw new Meteor.Error('403', 'No permissions!');\n\n    if (userId !== party.owner && (party.invited || []).indexOf(userId) == -1) {\n      Parties.collection.update(partyId, {$addToSet: {invited: userId}});\n\n      let from = getContactEmail(Meteor.users.findOne(this.userId));\n      let to = getContactEmail(Meteor.users.findOne(userId));\n\n      if (Meteor.isServer && to) {\n        Email.send({\n          from: 'noreply@socially.com',\n          to: to,\n          replyTo: from || undefined,\n          subject: 'PARTY: ' + party.name,\n          text: `Hi, I just invited you to ${party.name} on Socially.\n                        \\n\\nCome check it out: ${Meteor.absoluteUrl()}\\n`\n        });\n      }\n    }\n  },\n  reply: function(partyId: string, rsvp: string) {\n    check(partyId, String);\n    check(rsvp, String);\n\n    if (!this.userId)\n      throw new Meteor.Error('403', 'You must be logged-in to reply');\n\n    if (['yes', 'no', 'maybe'].indexOf(rsvp) === -1)\n      throw new Meteor.Error('400', 'Invalid RSVP');\n\n    let party = Parties.findOne({ _id: partyId });\n\n    if (!party)\n      throw new Meteor.Error('404', 'No such party');\n\n    if (party.owner === this.userId)\n      throw new Meteor.Error('500', 'You are the owner!');\n\n    if (!party.public && (!party.invited || party.invited.indexOf(this.userId) == -1))\n      throw new Meteor.Error('403', 'No such party'); // its private, but let's not tell this to the user\n\n    let rsvpIndex = party.rsvps ? party.rsvps.findIndex((rsvp) => rsvp.userId === this.userId) : -1;\n\n    if (rsvpIndex !== -1) {\n      // update existing rsvp entry\n      if (Meteor.isServer) {\n        // update the appropriate rsvp entry with $\n        Parties.update(\n          { _id: partyId, 'rsvps.userId': this.userId },\n          { $set: { 'rsvps.$.response': rsvp } });\n      } else {\n        // minimongo doesn't yet support $ in modifier. as a temporary\n        // workaround, make a modifier that uses an index. this is\n        // safe on the client since there's only one thread.\n        let modifier = { $set: {} };\n        modifier.$set['rsvps.' + rsvpIndex + '.response'] = rsvp;\n\n        Parties.update(partyId, modifier);\n      }\n    } else {\n      // add new rsvp entry\n      Parties.update(partyId,\n        { $push: { rsvps: { userId: this.userId, response: rsvp } } });\n    }\n  }\n});"]},"version":"1","isExternal":true,"dependencies":{"modules":["both/collections/parties.collection.ts"],"refFiles":[],"refTypings":[],"mappings":{"../collections/parties.collection":{"resolvedPath":"both/collections/parties.collection","external":false}}},"diagnostics":{"syntacticErrors":[],"semanticErrors":[{"code":2307,"fileName":"both/methods/parties.methods.ts","message":"Cannot find module 'meteor/email'.","line":2,"column":21},{"code":2307,"fileName":"both/methods/parties.methods.ts","message":"Cannot find module 'meteor/check'.","line":3,"column":21},{"code":2307,"fileName":"both/methods/parties.methods.ts","message":"Cannot find module 'meteor/meteor'.","line":4,"column":22}]},"hash":"1e353b5751c30aa3929d8a508f5cf75a4c48373a"}